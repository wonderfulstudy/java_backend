# 面向对象编程

[TOC]

## 第一章：类与对象

### 1.面向对象简介

### 2.类与对象简介

### 3.类与对象的定义及使用

### 4.对象内存分析

堆内存：保存的是对象的具体信息在程序之中堆内存空间的开辟是通过new关键字。

栈内存：保存的是一块堆内存的地址，即：通过地址找到堆内存，而后找到

![内存分析](/home/xiao_qi/Documents/Java后端/Java核心基础/img/深度截图_选择区域_20200225101212.png)

![内存分析](/home/xiao_qi/Documents/Java后端/Java核心基础/img/深度截图_选择区域_20200225101542.png)

对象实例化的两种语法：一、声明并实例化对象；二、、声明和实例化分开

![分布处理](/home/xiao_qi/Documents/Java后端/Java核心基础/img/深度截图_选择区域_20200225101942.png)

所有的类方法在声明实例化之后才能调用。对象必须在声明实例化之后才能使用。

### 5.对象引用分析

![应用传递](/home/xiao_qi/Documents/Java后端/Java核心基础/img/深度截图_选择区域_20200225102642.png)

类方法实现引用传递：

![类方法实现引用传递](/home/xiao_qi/Documents/Java后端/Java核心基础/img/深度截图_选择区域_20200225103311.png)

### 6.引用与垃圾产生分析

垃圾：没有被栈内存指向的堆内存。

## 第二章：深入分析类与对象

### 1.成员属性封装

获取或设置成员属性使用setXxx()、getXxx()方法；

类中的所有属性必须使用private修饰，获取方法必须使用内部方法。

### 2.构造方法与匿名对象

-   构造方法名称必须与类名称保持一致
-   构造方法不允许设置任何的返回值类型
-   构造方法是使用关键字new实例化对象的时候自动调用的

**为什么构造方法不允许设置返回值：**

**构造方法没有返回值为什么不用void定义：**

程序编译器是根据代码结构来进行编译处理的，执行的时候也是根据代码结构处理的。

## 第三章：this关键字

### 1.this调用本类属性

### 2.this调用本类方法

### 3.综合实战：简单Java类

## 第四章：static关键字

### 1.声明static属性

static修饰公共属性，非static属性必须在实例化对象产生之后才可以使用，而static属性可以在没有实例化对象可以通过类名访问。

### 2.声明static方法

static方法的主要特点在于，其可以不用实例化对象直接访问。

static中不能使用this。

static方法不能调用非static方法。

### 3.static应用案例

## 第五章：代码块

同步代码块

### 1.普通代码块

{}包括的代码。

### 2.构造代码块

每次都优先调用构造代码块，在调用构造方法。

### 3.静态代码块

静态块最先执行，静态代码块优先与主方法执行。

```
static{
	//代码内容
}
```

## 第六章：数组的定义与使用

### 1.数组的基本定义

- 数组的动态初始化
	- 数组类型 数组名称[] = new 数组类型 [长度]
	- 数组类型 [] 数组名称 = new 数组类型 [长度]
- 数组的静态初始化
	- 数组类型 数组名称[] = new 数组类型 {数据1，数据2，...，数据n}
	- 数组类型 数组名称[] = {数据1，数据2，...，数据n}

数组只有实例化对象之后才能使用，不然会报错。

### 2.foreach输出

语法格式：

```
for(数据类型 变量:数组|集合){}
```

避免使用数组下表使用数组数据。

### 3.数组与方法

### 4.数组排序案例分析

### 5.数组转置案例分析

### 6.方法可变参数

```
public static int sum(int ... data){}
```

可变参数的本质依然属于数组。

## 第七章：String类特点分析

### 1.String类对象两种实例化方式比较

**直接赋值实例化**

Java底层提供有专门的字符串池，因此两个相同字符串的直接赋值对应的地址相同。

**构造方法实例化**

使用构造方法实例化String对象，不会出现将字符串保存到String对象池的操作。

*直接入池的方法*

```
String str = new String("字符串").intern();
```

### 2.String对象（常量）池

Java中的对象（常量）池分为两种：

- 静态常量池

	程序在加载时会自动将此程序保存的字符串、普通常量、类和方法的信息等，全部进行分配

- 运行时常量池

	程序加载之后，程序里的一些变量提供的常量池

### 3.字符串修改分析

字符串长度不可改变。字符串的改变只是字符串指向的改变，并且可能产生垃圾。

String类的内容不应频繁修改。

## 第八章：String类常用方法

### 1.JavaDoc文档简介

## 第九章：继承的定义与使用

### 1.继承定义的限制

Java存在单继承限制，Java只允许一个class继承自一个类。

## 第十章：覆写

### 1.final关键字

定义不能被覆写的方法、变量使用final关键字。

## 第十一章：Annotation注解

## 第十二章：多态性

### 1.多态性简介

多态性是在继承性的基础之上扩展出来的，多态可以实现父子类之间的相互转换处理。

**Java中多态性的两种实现：**

- 方法的多态性
	- 方法的重载：同一个方法根据传入参数的不同实现不同的功能
	- 方法的覆写：同一个方法根据使用方法的子类的不同，实现的功能不同
- 对象的多态性：父子实例之间的转换处理
	- 对象向上转型：父类 父类实例 = 子类实例、自动完成转换
	- 对象向下转型：子类 子类实例 = （子类）父类实例、强制完成转换

### 2.对象向上转型(接收或返回参数的统一性)

向上转型的主要特点是能实现参数的统一设计。

### 3.对象向下转型

当程序需要使用子类的定义时需要使用向下转型。向上描述的是一些公共的属性，向下描述的是子类特殊的实现。向下转型并不是一件安全的事情，因为向下转型之前一定会实现向上转型。

### 4.instanceof关键字

向下转型并不是安全的，因此在向下转型之前应该判断。判断某个实例是否是某个类的对象，这个就需要通过instanceof语法判断。

语法：

​	对象 instanceof 类

## 第十三章：Object类

### 1.Object类的基本信息

Object类的主要特点是可以解决参数的统一问题，Object类可以接收所有的数据类型。

### 2.取得对象信息（toString）

toString方法默认输出类的基本信息。

### 3.对象比较（equals）

比较两个类的内容的不同。默认情况下Object类中的equals方法只是进行类两个类地址的判断，因此要想正确判断必须在子类中实现equals方法的覆写。

## 第十四章：抽象类的定义与使用

### 1.抽象类基本概念

在实际开发中我们很少继承一个已经完善的类，而是必须要继承抽象类（父类强制子类必须覆写某个方法）。

**抽象类的基本定义**

抽象类的主要作用在于对子类中覆写方法进行约定，抽象类必须使用abstract关键字定义。（在普通类的基础上追加抽象方法就是抽象类）抽象类是不能直接使用的。

使用抽象类的条件：

- 抽象类必须提供有子类，子类使用extends继承一个抽象类；
- 抽象类的子类（不是抽象类）一定要覆写抽象类中的全部抽象方法；
- 抽象类的对象实例化可以利用对象多态性通过子类向上转型的方式完成；

**对于抽象类使用的几点意见：**

- 抽象类使用很大程度上有一个核心的问题：抽象类自己无法直接实例化；
- 抽象类之中主要的目的是进行过渡操作使用，所以当你要使用抽象类进行开发的时候，往往都是在你设计中所要解绝继承问题所带来的代码重复的问题。

### 2.抽象类的相关说明

- 抽象类中不能出现final关键字
- 抽象类可以提供有构造方法，并且子类也一定会按照子类对象的实例化原则进行父构造调用
- 抽象类中允许没有抽象方法，即使如此也无法直接实例化
- 抽象类中可以提供有static方法，并且不受抽象类无法实例化约束

### 3.模板设计模式

抽象类最大的好处一是对子类方法的统一管理，二是可以自身提供一些普通方法，并且普通方法可以调用抽象方法（必须在有子类提供实现的时候才会生效）。

抽象类应该抽象行为。

## 第十五章：包装类

### 1.包装类实现原理分析

Object类是所有类的父类，Object类可以接收所有的数据类型。但是基本数据类型并不是一个类，所以现在如果要想将基本数据类型以类的形式处理就要对它进行包装。

**Java中的包装类：**

- 对象型包装类
- 数值型包装类

### 2.装箱与拆箱

装箱：将基本数据类型保存在包装了类之中

拆箱：从包装类对象中获取基本数据类型

## 第十六章：接口的定义与使用

### 1.接口基本定义

接口定义语法：

```
interface IPerson{}
```

由于接口的定义与类的定义方法相同，所以接口名首字母应为I(interface)。

接口肯定无法直接产生实例化对象，对于接口的实现的注意事项：

- 接口需要被子类实现(implements)，一个子类可以实现多个父接口；
- 子类（如果不是抽象类）那么一定要覆写接口之中的全部抽象方法；
- 接口对象可以利用子类对象的向上转型进行实例化

### 2.接口定义加强

接口中可以有普通方法，接口中的普通方法必须追加default的声明。

除了追加普通方法，接口中也可以添加static方法。

### 3.使用接口定义标准

接口开发最重要的应用就是进行标准的制定。

### 4.工厂设计模式



### 5.代理设计模式

### 6.抽象类与接口区别

## 第十七章：泛型

### 1.泛型的基本定义

使用泛型避免了对象的想下转型处理，可以避免安全隐患。

泛型的使用注意点：

- 泛型之中只允许设置引用类型，如果要操作基本数据类型使用对应的包装类
- 从JDK1.7开始，泛型对象实例化可以简化为：`Point<Interage> point = new Point<>();`

### 2.泛型通配符

使用通配符处理时能够正常接收数据，但是方法内部不能修改。

在“？”这个通配符的基础上还提供了两类通配符：

- ？extends 类：设置泛型的上限
- ？super类：设置泛型的下限

## 第十八章：包的定义及使用

### 1.包的定义

### 2.包的导入

所有的包名称都要小写。“*”只导入会被使用的类，其性能和单独导入完全相同。

## 第十九章：单例设计模式

## 第二十章：异常的捕获及处理

### 1.处理异常

异常处理语句：

- try...catch
- try...catch...fianlly
- try...finally

### 2.处理多个异常

使用多个catch捕获多个异常。

### 3.异常处理流程

- 产生异常后程序自动实例化异常类
- 将产生的异常与catch中的异常进行比对，成功则执行catch中的代码，没有匹配项则执行finally中的语句
- 执行finally后在判断异常是否被处理，如果被处理则继续执行后面的代码，否则退出程序

程序之中异常的最大的类型就是Throwable，而其中有两个子类：

- Error：程序还未执行出现的错误，开发者无法处理；
- Exception：程序中出现的异常，开发者可以处理

**简化异常处理**

将异常处理类向上转型，扩大异常处理范围。

### 4.throws关键字

throws强制使用者处理异常，throws向上抛出异常。

### 5.throw关键字

throw手工进行异常抛出。

### 6.异常处理模型

### 7.RuntimeException

如果在所有的程序执行上只要使用了throws定义的方法都必须手工处理就太麻烦了，所以Java提供有一个灵活的可选异常处理父类RuntimeException，此时子类可以不要强制性处理。

### 8.自定义异常类

两种方案：

- 继承Exception
- 继承RuntimeException

## 第二十一章：函数式编程

### 1.Lamda表达式

要求：SAM



### 2.方法引用

### 3.内建函数式接口

